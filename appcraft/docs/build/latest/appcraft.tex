%% Generated by Sphinx.
\def\sphinxdocclass{article}
\IfFileExists{luatex85.sty}
 {\RequirePackage{luatex85}}
 {\ifdefined\luatexversion\ifnum\luatexversion>84\relax
  \PackageError{sphinx}
  {** With this LuaTeX (\the\luatexversion),Sphinx requires luatex85.sty **}
  {** Add the LaTeX package luatex85 to your TeX installation, and try again **}
  \endinput\fi\fi}
\documentclass[letterpaper,10pt,english]{sphinxhowto}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[Scale=0.9,
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}


    \usepackage{commonunicode}
    \directlua {
        luaotfload.add_fallback("emoji",
        {
            "[NotoColorEmoji-Regular.ttf]:mode=harf;",
            "[TwemojiMozilla.ttf]:mode=harf;",
            "[DejaVuSans.ttf]:mode=harf;",
        })
    }
    \setmainfont{NotoSans}[
        RawFeature={fallback=emoji},
    ]
    \setsansfont{NotoSans}[RawFeature={fallback=emoji}]
    \setmonofont{DejaVuSansMono}[RawFeature={fallback=emoji},Scale=0.8]
    

\title{Appcraft}
\date{Mar 13, 2025}
\release{0.5.4}
\author{Dux Tecnologia, Thiago Costa Pereira}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\noindent\sphinxincludegraphics[width=200\sphinxpxdimen,height=200\sphinxpxdimen]{{logo}.png}

\sphinxAtStartPar
Welcome to the Appcraft documentation for version 0.5.4!

\sphinxAtStartPar
Appcraft is a modular framework designed to simplify software development by providing a structured and extensible architecture. It enables developers to create and manage complex applications with ease, ensuring scalability and maintainability.

\sphinxAtStartPar
This version includes all the essential features and modules to help you get started with AppCraft.

\sphinxstepscope


\section{Getting Started}
\label{\detokenize{getting_started:getting-started}}\label{\detokenize{getting_started::doc}}
\sphinxAtStartPar
To get started with AppCraft, follow these steps:


\subsection{Installation}
\label{\detokenize{getting_started:installation}}
\sphinxAtStartPar
To install AppCraft, simply run the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip\PYG{+w}{ }install\PYG{+w}{ }appcraft
\end{sphinxVerbatim}


\subsection{Starting a New Project}
\label{\detokenize{getting_started:starting-a-new-project}}
\sphinxAtStartPar
To start a new project, follow these steps:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} \begin{description}
\sphinxlineitem{Create a new directory for your project:}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
mkdir\PYG{+w}{ }project\PYGZus{}name
\PYG{n+nb}{cd}\PYG{+w}{ }project\PYGZus{}name
\end{sphinxVerbatim}

\end{description}

\item {} 
\sphinxAtStartPar
Initialize the project using one of the following commands:

\end{enumerate}
\begin{itemize}
\item {} \begin{description}
\sphinxlineitem{To initialize the project with the desired templates using the following command:}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
appcraft\PYG{+w}{ }init\PYG{+w}{ }\PYGZlt{}template\PYGZus{}names\PYGZgt{}
\end{sphinxVerbatim}

\end{description}

\item {} \begin{description}
\sphinxlineitem{Where \sphinxtitleref{<template\_names>} should be replaced by the names of the templates you want to use, separated by spaces. For example:}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
appcraft\PYG{+w}{ }init\PYG{+w}{ }logs\PYG{+w}{ }locales\PYG{+w}{ }flask\PYGZus{}ui\PYG{+w}{ }flask\PYGZus{}api\PYG{+w}{ }sqlalchemy
\end{sphinxVerbatim}

\sphinxAtStartPar
This will initialize your project with the specified templates. Make sure to separate each template name with a space.

\end{description}

\item {} \begin{description}
\sphinxlineitem{Or, to list available templates}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
appcraft\PYG{+w}{ }list\PYGZus{}templates
\end{sphinxVerbatim}

\sphinxAtStartPar
For more details on available templates, refer to the \sphinxhref{templates/index.html}{Templates Documentation}.

\end{description}

\end{itemize}

\sphinxstepscope


\section{Templates}
\label{\detokenize{templates/index:templates}}\label{\detokenize{templates/index::doc}}
\sphinxAtStartPar
In AppCraft, templates define the foundation of a \sphinxstylestrong{layered architecture}, ensuring modularity and independence. Each template provides a specific set of features that seamlessly integrate into a project.

\sphinxAtStartPar
All templates are \sphinxstylestrong{modular and independent}, allowing them to be combined as needed, making project construction \sphinxstylestrong{flexible and scalable}. Whether you require \sphinxstylestrong{logging, localization, web interfaces, or API handling}, you can mix and match templates without compromising the core structure of your application.

\sphinxAtStartPar
By leveraging AppCraft’s template\sphinxhyphen{}based system, developers can streamline development while maintaining a \sphinxstylestrong{clean and maintainable architecture}.

\sphinxstepscope


\subsection{Base Template}
\label{\detokenize{templates/base/index:base-template}}\label{\detokenize{templates/base/index::doc}}
\sphinxAtStartPar
The \sphinxstylestrong{Base Template} is the foundational template of the framework, providing the backbone for the project’s architecture in layers. It serves as the starting point for any application using the framework, offering a solid foundation and essential functionalities for efficient project management.


\subsubsection{Key Features:}
\label{\detokenize{templates/base/index:key-features}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Simplified Management and Execution of EntryPoints}: The Base Template facilitates the setup and execution of various entry points in your project, allowing you to define and organize the core functions of your application.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Automatic Management and Installation of Missing Dependencies}: The template automatically handles the installation of dependencies, ensuring that your project has everything it needs to run correctly without requiring manual setup.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Error Handler}: It includes a robust error handling mechanism, allowing you to capture and manage exceptions appropriately, ensuring the stability and integrity of the system.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{CLI UI Theme}: The Base Template includes a user interface theme for the CLI, providing a visually organized and consistent way to interact with the system, improving the user experience.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Customizable Message Printer}: The template offers a system for printing custom messages, allowing you to display different types of messages (such as success, warning, error, critical, title, and info) in a clear and formatted way, making communication with users easier during execution.

\end{itemize}


\subsubsection{Benefits:}
\label{\detokenize{templates/base/index:benefits}}
\sphinxAtStartPar
With these features, the Base Template establishes a solid and easy\sphinxhyphen{}to\sphinxhyphen{}use foundation for building and expanding projects, keeping them organized while offering great control over dependencies and user interaction.

\sphinxstepscope


\subsection{Logs Template}
\label{\detokenize{templates/logs/index:logs-template}}\label{\detokenize{templates/logs/index::doc}}
\sphinxAtStartPar
The \sphinxstylestrong{Logs Template} provides a structured and efficient logging system, enhancing error tracking, debugging, and application monitoring. It ensures logs are properly stored, rotated, and formatted to maintain clear visibility of system events.

\sphinxAtStartPar
The \sphinxstylestrong{Logs Template} is seamlessly integrated into the framework’s \sphinxstylestrong{Core}, operating automatically without requiring additional setup or manual imports. It ensures all logging functionality is readily available across the application.


\subsubsection{Key Features}
\label{\detokenize{templates/logs/index:key-features}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Structured Logging System:}
Implements a well\sphinxhyphen{}organized logging mechanism that categorizes logs by severity levels, ensuring clarity in debugging and monitoring.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Log Rotation for Efficient Storage Management:}
Automatically rotates log files based on time intervals or file size limits, preventing excessive log growth and improving performance.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Configurable Logging Levels:}
Supports various logging levels (\sphinxtitleref{DEBUG}, \sphinxtitleref{INFO}, \sphinxtitleref{WARNING}, \sphinxtitleref{ERROR}, \sphinxtitleref{CRITICAL}), allowing fine\sphinxhyphen{}grained control over log verbosity and filtering.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Multiple Output Formats:}
Provides structured log formats, including plain text and JSON, making it adaptable for both human\sphinxhyphen{}readable logs and machine\sphinxhyphen{}parsed analytics.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Enhanced Debug Mode:}
In development mode, integrates \sphinxstylestrong{structlog, better\sphinxhyphen{}exceptions, and rich} to provide visually improved, color\sphinxhyphen{}coded, and more readable terminal logs.

\end{itemize}


\subsubsection{Benefits}
\label{\detokenize{templates/logs/index:benefits}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Improved Error Tracking \& Debugging:}
Enables faster identification of issues by structuring logs in a clear and organized format.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Optimized Log Storage Management:}
Automatic log rotation prevents excessive disk usage and keeps logs well\sphinxhyphen{}organized over time.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Seamless Framework Integration:}
Operates directly within the framework, eliminating the need for additional configurations or external logging setups.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Developer\sphinxhyphen{}Friendly Debugging:}
Provides enhanced, visually formatted logs in debug mode, making it easier to trace and understand errors.

\end{itemize}

\sphinxAtStartPar
The \sphinxstylestrong{Logs Template} delivers a powerful, automated logging solution that enhances application monitoring and debugging while ensuring logs remain structured, scalable, and easy to manage.

\sphinxstepscope


\subsection{Locales Template}
\label{\detokenize{templates/locales/index:locales-template}}\label{\detokenize{templates/locales/index::doc}}
\sphinxAtStartPar
The \sphinxstylestrong{Locales Template} provides a comprehensive \sphinxstylestrong{internationalization (i18n) system}, enabling seamless multilingual support within applications. It ensures that messages, commands, and outputs are dynamically translated based on the user’s locale, improving accessibility and usability across different languages.
The \sphinxstylestrong{Locales Template} is fully integrated into the framework’s \sphinxstylestrong{Core}, requiring no additional setup. It leverages a built\sphinxhyphen{}in translation system to dynamically load locale\sphinxhyphen{}specific resources and ensures smooth adaptation to multiple languages.


\subsubsection{Key Features:}
\label{\detokenize{templates/locales/index:key-features}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Dynamic Language Detection:}
The template automatically detects the system’s preferred language or allows users to specify their preferred locale for translations.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Message Translation with Gettext Support:}
It leverages the \sphinxstylestrong{gettext} system for managing translations, supporting \sphinxstylestrong{.po and .mo files}, ensuring efficiency in message handling.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Automatic Compilation of Translation Files:}
The template detects uncompiled translation files and \sphinxstylestrong{automatically compiles them}, ensuring that translations are always up to date.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{CLI Message Translation:}
The \sphinxstylestrong{Locales Template} intercepts standard print operations, ensuring that messages displayed in the command\sphinxhyphen{}line interface are automatically translated before being printed.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Seamless Framework Integration:}
Designed to work natively within the framework, the template requires no external dependencies and follows a modular structure for efficient multilingual support.

\end{itemize}


\subsubsection{Benefits:}
\label{\detokenize{templates/locales/index:benefits}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Effortless Internationalization:}
Automatically manages translations without requiring manual intervention, providing a smooth multilingual experience.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Consistent User Experience:}
Ensures that users receive messages in their preferred language, improving accessibility and usability.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Automated Translation Handling:}
Automatically compiles missing translation files, keeping them updated without additional configuration.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Integrated CLI Localization:}
Command\sphinxhyphen{}line outputs are localized dynamically, reducing the need for hardcoded translations in scripts.

\end{itemize}

\sphinxAtStartPar
The \sphinxstylestrong{Locales Template} offers a fully integrated, scalable, and automated approach to internationalization, ensuring that applications can adapt efficiently to multiple languages without additional complexity.

\sphinxstepscope


\subsection{Flask UI Template}
\label{\detokenize{templates/flask_ui/index:flask-ui-template}}\label{\detokenize{templates/flask_ui/index::doc}}
\sphinxAtStartPar
The \sphinxstylestrong{Flask UI Template} provides an integrated \sphinxstylestrong{FlaskApp} that can function independently or in combination with the \sphinxstylestrong{Flask API} and \sphinxstylestrong{SQLAlchemy} templates if installed. It ensures a seamless integration within a \sphinxstylestrong{layered architecture}, maintaining modularity and flexibility in web application development.

\sphinxAtStartPar
This template introduces a well\sphinxhyphen{}structured \sphinxstylestrong{presentation layer} for UI endpoints under \sphinxtitleref{presentation/web/ui}, offering built\sphinxhyphen{}in support and examples for constructing \sphinxstylestrong{Web UIs} efficiently.. It automatically sets up a \sphinxstylestrong{Flask application}, configures \sphinxstylestrong{routing} for \sphinxstylestrong{dynamic views, static views, and assets} and includes \sphinxstylestrong{error handling} for missing routes.

\sphinxAtStartPar
Additionally, if the \sphinxstylestrong{SQLAlchemy Template} is installed, the \sphinxstylestrong{Flask UI Template} will attempt to initialize the database connection, providing built\sphinxhyphen{}in support for ORM\sphinxhyphen{}based persistence. Otherwise, it gracefully operates without database integration, ensuring versatility in different application setups.

\sphinxstepscope


\subsection{Flask API Template}
\label{\detokenize{templates/flask_api/index:flask-api-template}}\label{\detokenize{templates/flask_api/index::doc}}
\sphinxAtStartPar
The \sphinxstylestrong{Flask API Template} provides an integrated \sphinxstylestrong{FlaskApp} that can function independently or in combination with the \sphinxstylestrong{Flask API} and \sphinxstylestrong{SQLAlchemy} templates if installed. It ensures a seamless integration within a \sphinxstylestrong{layered architecture}, maintaining modularity and flexibility in web application development.

\sphinxAtStartPar
This template introduces a well\sphinxhyphen{}structured \sphinxstylestrong{presentation layer} for API endpoints under \sphinxtitleref{presentation/web/api/v1}, offering built\sphinxhyphen{}in support and examples for constructing \sphinxstylestrong{RESTful APIs} efficiently.. It automatically sets up a \sphinxstylestrong{Flask application}, configures \sphinxstylestrong{routing} for \sphinxstylestrong{APIs} and includes \sphinxstylestrong{error handling} for missing routes.

\sphinxAtStartPar
This template is designed to manage \sphinxstylestrong{APIs}, offering built\sphinxhyphen{}in support and examples for constructing \sphinxstylestrong{RESTful APIs} efficiently. It automatically sets up a \sphinxstylestrong{Flask application}, configures \sphinxstylestrong{routing} and includes \sphinxstylestrong{error handling} for missing routes.

\sphinxAtStartPar
This template includes essential \sphinxstylestrong{API dependencies}, such as:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{flask\sphinxhyphen{}login} (user authentication)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{flask\sphinxhyphen{}restful} (simplified API routing)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{flask\sphinxhyphen{}cors} (cross\sphinxhyphen{}origin resource sharing)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{flask\sphinxhyphen{}compress} (response compression)

\end{itemize}

\sphinxAtStartPar
Additionally, if the \sphinxstylestrong{SQLAlchemy Template} is installed, the \sphinxstylestrong{Flask API Template} will attempt to initialize the database connection, providing built\sphinxhyphen{}in support for ORM\sphinxhyphen{}based persistence. Otherwise, it gracefully operates without database integration, ensuring versatility in different application setups.

\sphinxstepscope


\subsection{Web Scraping Template}
\label{\detokenize{templates/web_scraping/index:web-scraping-template}}\label{\detokenize{templates/web_scraping/index::doc}}
\sphinxAtStartPar
The \sphinxstylestrong{Web Scraping Template} provides a structured environment for efficiently extracting data from websites. It includes \sphinxstylestrong{pre\sphinxhyphen{}configured scripts} and essential libraries for handling web requests, parsing HTML, and automating interactions with web pages.


\subsubsection{Key Features}
\label{\detokenize{templates/web_scraping/index:key-features}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Multiple Web Scraping Adapters:} The template includes an \sphinxstylestrong{adapter for each scraping library}, allowing flexibility in choosing the best approach for different use cases.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Standardized Architecture:} It provides an \sphinxstylestrong{abstract base class} for web scraping adapters, ensuring a \sphinxstylestrong{consistent and reusable} structure across different implementations.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Service Demonstrations:} It includes examples of \sphinxstylestrong{data extraction and storage services}, showcasing best practices for handling scraped data.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Included Dependencies}
\begin{quote}
\begin{quote}

\sphinxAtStartPar
This template integrates powerful web scraping tools, such as:
\end{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{browser\_manager} (headless browser management)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{scrapy} (high\sphinxhyphen{}level web scraping framework)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{selenium} (browser automation)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{requests \& requests\sphinxhyphen{}html} (HTTP requests and dynamic content rendering)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{beautifulsoup4, lxml, pyquery} (HTML/XML parsing)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{fake\sphinxhyphen{}useragent} (randomized user agents for avoiding detection)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{retrying \& tenacity} (automatic request retrying for failed attempts)

\end{itemize}
\end{quote}

\end{itemize}

\sphinxstepscope


\subsection{Git Template}
\label{\detokenize{templates/git/index:git-template}}\label{\detokenize{templates/git/index::doc}}
\sphinxAtStartPar
The \sphinxstylestrong{Git Template} serves as a foundational setup for initializing a local Git repository, establishing a structured branching strategy tailored to various development environments. This template ensures a standardized workflow, facilitating seamless collaboration and efficient version management across different stages of development.


\subsubsection{Key features:}
\label{\detokenize{templates/git/index:key-features}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Structured Branching Strategy:} The template introduces an organized branching model that aligns with semantic versioning and distinct development environments, including:
\sphinxhyphen{} \sphinxstylestrong{Development (`dev`):} A branch dedicated to active development and integration of new features.
\sphinxhyphen{} \sphinxstylestrong{Alpha (`alpha`):} An environment for early testing phases, allowing for initial feedback and iterative improvements.
\sphinxhyphen{} \sphinxstylestrong{Beta (`beta`):} A pre\sphinxhyphen{}release stage focusing on refining features and addressing identified issues before the final release.
\sphinxhyphen{} \sphinxstylestrong{Production (`production`):} The stable branch representing the live application, ensuring reliability and performance for end\sphinxhyphen{}users.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Initial Repository Setup:} Upon initialization, the template configures the local repository with the aforementioned branches, providing a clear pathway for code progression from development to production.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Environment\sphinxhyphen{}Specific Configurations:} Each branch is equipped with configurations pertinent to its respective environment, facilitating tailored testing, deployment, and monitoring processes.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Semantic Versioning Integration:} The branching strategy incorporates semantic versioning principles, promoting clarity in version management and release cycles.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{GitAdapter Integration:} The template includes a \sphinxstylestrong{GitAdapter} component, designed to streamline interactions with Git. This adapter simplifies command executions, automates routine tasks, and provides a consistent interface for Git operations, enhancing productivity and reducing the potential for errors.

\end{itemize}


\subsubsection{Benefits:}
\label{\detokenize{templates/git/index:benefits}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Consistent Workflow:} By adhering to a predefined branching strategy, teams can maintain a consistent workflow, reducing complexities associated with code integration and deployment.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Enhanced Collaboration:} Clear delineation of development stages allows team members to work concurrently on different aspects of the project without conflicts, streamlining collaboration efforts.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Improved Release Management:} Structured branches corresponding to specific environments enable systematic testing and deployment, enhancing the overall quality and reliability of releases.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Simplified Git Operations:} With the GitAdapter, developers can perform Git operations more efficiently, focusing on development tasks rather than manual version control management.

\end{itemize}

\sphinxAtStartPar
The \sphinxstylestrong{Git Template} serves as a robust framework for managing codebases, ensuring that development practices are standardized, efficient, and scalable across various environments.

\sphinxstepscope


\subsection{GitHub Template}
\label{\detokenize{templates/github/index:github-template}}\label{\detokenize{templates/github/index::doc}}
\sphinxAtStartPar
The \sphinxstylestrong{GitHub Template} extends the capabilities of the \sphinxstylestrong{Git Template} by integrating GitHub repository management, ensuring that project repositories are configured with essential metadata and remote origin settings. This template automates the process of creating repositories based on project configurations, simplifying repository initialization and remote synchronization.

\sphinxAtStartPar
\sphinxstylestrong{Prerequisite: Git Template}
The \sphinxstylestrong{GitHub Template} builds upon the \sphinxstylestrong{Git Template}, leveraging its structured branching strategy and GitAdapter for seamless repository management. Before using the \sphinxstylestrong{GitHub Template}, ensure that the \sphinxstylestrong{Git Template} is applied to set up the local repository.


\subsubsection{Key Features:}
\label{\detokenize{templates/github/index:key-features}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Automatic Repository Creation:}
The template automates the creation of GitHub repositories using project\sphinxhyphen{}defined settings, ensuring consistency across multiple projects.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Project Metadata Integration:}
It fetches the \sphinxstylestrong{project name} and \sphinxstylestrong{description} from the project configuration and applies them to the repository, providing a structured and informative repository setup.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Remote Origin Configuration:}
The local Git repository is automatically linked to the corresponding GitHub repository, setting it as the \sphinxstylestrong{remote origin} to enable seamless push and pull operations.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Branch Structure Inheritance:}
Since it extends the \sphinxstylestrong{Git Template}, all structured branching strategies (\sphinxtitleref{dev}, \sphinxtitleref{alpha}, \sphinxtitleref{beta}, and \sphinxtitleref{production}) are maintained, ensuring a well\sphinxhyphen{}defined development and release workflow.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{GitAdapter Integration:}
The \sphinxstylestrong{GitHub Template} leverages the \sphinxstylestrong{GitAdapter} to manage repository interactions with GitHub efficiently, simplifying operations like pushing changes, checking repository status, and handling authentication.

\end{itemize}


\subsubsection{Benefits:}
\label{\detokenize{templates/github/index:benefits}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Automated GitHub Repository Setup:}
Reduces manual configuration steps by automatically initializing and linking repositories to GitHub.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Consistent Project Metadata:}
Ensures that repository details, such as name and description, are properly set based on project definitions.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Streamlined Remote Management:}
Eliminates the need for manual \sphinxtitleref{git remote add origin} commands, making repository synchronization effortless.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Standardized Version Control Workflow:}
By inheriting the \sphinxstylestrong{Git Template}, it maintains a structured approach to branching and versioning across all repositories.

\end{itemize}

\sphinxAtStartPar
The \sphinxstylestrong{GitHub Template} provides an automated and standardized approach to managing repositories on GitHub, reducing manual configuration efforts and ensuring consistency across projects. 🚀

\sphinxstepscope


\section{Layered Architecture}
\label{\detokenize{architecture/index:layered-architecture}}\label{\detokenize{architecture/index::doc}}
\sphinxAtStartPar
In this section, we introduce the \sphinxstylestrong{Layered Architecture} of the AppCraft framework. The architecture follows a clean and modular design, ensuring flexibility and scalability. The system is divided into multiple layers, each with distinct responsibilities, allowing for easy maintainability and extensibility.

\sphinxAtStartPar
The architecture layers are:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Runner}: The entry points of the application. It initiates the process and calls the \sphinxstylestrong{Presentation} layer or \sphinxstylestrong{Service} layer.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Presentation}: This layer handles the user interface and presentation logic. It interacts with the \sphinxstylestrong{Application} layer to present data to the user.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Application}: Manages interactions between the \sphinxstylestrong{Presentation} layer and the \sphinxstylestrong{Domain} layer. It handles business logic and operations, such as calling models from the \sphinxstylestrong{Domain} and managing adapters and frameworks from the \sphinxstylestrong{Infrastructure}.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Domain}: Represents the core business entities. This layer contains the application’s data models and business rules.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Infrastructure}: Includes all the external systems, frameworks, and adapters, such as databases, third\sphinxhyphen{}party services, file management, and more.

\end{enumerate}

\sphinxstepscope


\subsection{Runner Layer}
\label{\detokenize{architecture/runner/index:runner-layer}}\label{\detokenize{architecture/runner/index::doc}}
\sphinxAtStartPar
Runners are the entry points of the application. It initiates the process and calls the \sphinxstylestrong{Presentation} layer or \sphinxstylestrong{Service} layer.

\sphinxAtStartPar
Aqui está uma seção \sphinxstylestrong{“What to Do in Runners”} no mesmo formato das outras:


\subsubsection{What to Do in Runners}
\label{\detokenize{architecture/runner/index:what-to-do-in-runners}}\begin{itemize}
\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Bootstrap the Application}:}
\sphinxAtStartPar
The Runner is responsible for initializing the entire application. It should set up dependencies, load configurations, and start necessary services before the application starts handling requests.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Wire Up Dependencies}:}
\sphinxAtStartPar
Ensure that dependencies, such as repositories, services, and infrastructure components, are instantiated and injected properly. This avoids tight coupling and ensures dependency inversion is respected.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Load Environment Variables and Configurations}:}
\sphinxAtStartPar
The Runner should read and apply configuration settings from environment variables, configuration files, or a settings module to ensure flexibility and separation of concerns.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Register Application Components}:}
\sphinxAtStartPar
All necessary components, such as repositories, services, and external integrations, should be properly registered and made available to the application.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Handle Application Lifecycle Management}:}
\sphinxAtStartPar
Ensure proper shutdown procedures are in place, such as closing database connections, stopping background jobs, and releasing resources when the application stops.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Integrate Logging and Monitoring}:}
\sphinxAtStartPar
Set up logging configurations and monitoring tools to track application performance and diagnose issues effectively.

\end{description}

\end{itemize}


\subsubsection{What to Avoid in Runners}
\label{\detokenize{architecture/runner/index:what-to-avoid-in-runners}}
\sphinxAtStartPar
While creating runners in the AppCraft framework, it’s important to follow best practices to ensure the runners remain clean and focused on their intended purpose. Here are some things to avoid:
\begin{itemize}
\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Avoid Using Print Statements for Debugging}:}
\sphinxAtStartPar
Runners should not be used for logging or debugging purposes, such as using \sphinxtitleref{print()} statements. Print statements should be used in the Presentation layer when interacting with the user or displaying output. Logging, on the other hand, should be handled in the Service layer for better management and traceability of events.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Avoid Performing Complex Actions in Runners}:}
\sphinxAtStartPar
Runners should only handle the orchestration of tasks, such as calling the appropriate methods from the Presentation or Service layers. Avoid placing complex business logic, lengthy computations, or time\sphinxhyphen{}consuming actions directly in the runner methods.
For example, avoid making database queries, handling large data processing, or interacting with external systems directly inside the runner. This should be delegated to services or other components that can handle the workload asynchronously or in a more appropriate place.

\end{description}

\end{itemize}


\subsubsection{Types of runners}
\label{\detokenize{architecture/runner/index:types-of-runners}}
\sphinxAtStartPar
In the AppCraft framework, there are two types of runners:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Main Runners}:}
\sphinxAtStartPar
These are the primary entry points of the application. They are located in the \sphinxtitleref{runners/main} directory. These scripts are typically used for the main execution flow of the application.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Auxiliary/Secondary Runners}:}
\sphinxAtStartPar
These runners serve secondary tasks and are located in the \sphinxtitleref{runners/tools} directory. These scripts are typically used for secundary tasks that are not the main execution flow of the application.

\end{description}

\end{enumerate}

\sphinxAtStartPar
To define a class as a runner, it must meet the following conditions:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The class must be located in either \sphinxtitleref{runners/main} or \sphinxtitleref{runners/tools}.

\item {} 
\sphinxAtStartPar
The class must inherit from \sphinxtitleref{AppRunner}.

\item {} 
\sphinxAtStartPar
The methods that are designated as runners should be decorated with the \sphinxtitleref{@AppRunner.runner} decorator.

\end{itemize}


\subsubsection{Example of a Runner}
\label{\detokenize{architecture/runner/index:example-of-a-runner}}
\sphinxAtStartPar
Here is an example of how to define a runner:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{application}\PYG{n+nn}{.}\PYG{n+nn}{services}\PYG{n+nn}{.}\PYG{n+nn}{app\PYGZus{}service}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{AppService}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{infrastructure}\PYG{n+nn}{.}\PYG{n+nn}{framework}\PYG{n+nn}{.}\PYG{n+nn}{appcraft}\PYG{n+nn}{.}\PYG{n+nn}{core}\PYG{n+nn}{.}\PYG{n+nn}{app\PYGZus{}runner}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{AppRunner}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{infrastructure}\PYG{n+nn}{.}\PYG{n+nn}{memory}\PYG{n+nn}{.}\PYG{n+nn}{adapters}\PYG{n+nn}{.}\PYG{n+nn}{app\PYGZus{}adapter}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{AppAdapter}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{presentation}\PYG{n+nn}{.}\PYG{n+nn}{cli}\PYG{n+nn}{.}\PYG{n+nn}{app\PYGZus{}cli\PYGZus{}presentation}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{AppCLIPresentation}


\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{AppRunner}\PYG{p}{(}\PYG{n}{AppRunner}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nd}{@AppRunner}\PYG{o}{.}\PYG{n}{runner}
    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{start}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{app\PYGZus{}adapter} \PYG{o}{=} \PYG{n}{AppAdapter}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{app\PYGZus{}service} \PYG{o}{=} \PYG{n}{AppService}\PYG{p}{(}\PYG{n}{app\PYGZus{}adapter}\PYG{o}{=}\PYG{n}{app\PYGZus{}adapter}\PYG{p}{)}
        \PYG{n}{presentation} \PYG{o}{=} \PYG{n}{AppCLIPresentation}\PYG{p}{(}\PYG{n}{app\PYGZus{}service}\PYG{o}{=}\PYG{n}{app\PYGZus{}service}\PYG{p}{)}
        \PYG{n}{presentation}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{non\PYGZus{}runner1}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} This method does not show in the runner.}
        \PYG{k}{pass}
\end{sphinxVerbatim}


\subsubsection{Running Applications}
\label{\detokenize{architecture/runner/index:running-applications}}
\sphinxAtStartPar
To execute the \sphinxstylestrong{Main runners} within your project, use:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python\PYG{+w}{ }run
\end{sphinxVerbatim}

\sphinxAtStartPar
This command will run the \sphinxstylestrong{main runner} of your project that are located in the \sphinxtitleref{runners/main} folder.

\sphinxAtStartPar
If there are \sphinxstylestrong{multiple main runners}, you will be prompted to select the desired \sphinxstylestrong{filename, class, and method} in the \sphinxtitleref{runners/main} directory.

\sphinxAtStartPar
If you want to know how to \sphinxstylestrong{execute a specific runner}, refer to the section {\hyperref[\detokenize{architecture/runner/index:id2}]{\sphinxsamedocref{Executing a Specific Runner}}}.


\subsubsection{Running Auxiliary Runner}
\label{\detokenize{architecture/runner/index:running-auxiliary-runner}}
\sphinxAtStartPar
To execute \sphinxstylestrong{Auxiliary Runner} in your project, use:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python\PYG{+w}{ }run\PYGZus{}tools
\end{sphinxVerbatim}

\sphinxAtStartPar
This command will run the \sphinxstylestrong{auxiliary runner} of your project that are located in the \sphinxtitleref{runners/tools} folder.

\sphinxAtStartPar
If there are \sphinxstylestrong{multiple auxiliary runners}, you will be prompted to select the desired \sphinxstylestrong{filename, class, and method} in the \sphinxtitleref{runners/tools} directory.

\sphinxAtStartPar
If you want to know how to \sphinxstylestrong{execute a specific runner}, refer to the section {\hyperref[\detokenize{architecture/runner/index:id2}]{\sphinxsamedocref{Executing a Specific Runner}}}.


\subsubsection{Executing a Specific Runner}
\label{\detokenize{architecture/runner/index:id2}}
\sphinxAtStartPar
If you want to execute a specific runner, you can use the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python\PYG{+w}{ }run\PYG{+w}{ }file\PYGZus{}name\PYG{+w}{ }class\PYGZus{}name\PYG{+w}{ }method\PYGZus{}name
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{file\_name}: The name of the file containing the class runner.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{class\_name}: The name of the class runner.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{method\_name}: The name of the method within the class runner that you want to run.

\end{itemize}

\sphinxAtStartPar
If the class contains only one method, you can omit the \sphinxtitleref{method\_name}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python\PYG{+w}{ }run\PYG{+w}{ }file\PYGZus{}name\PYG{+w}{ }class\PYGZus{}name
\end{sphinxVerbatim}

\sphinxAtStartPar
If the file contains only one class, you can omit the \sphinxtitleref{class\_name}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python\PYG{+w}{ }run\PYG{+w}{ }file\PYGZus{}name\PYG{+w}{ }method\PYGZus{}name
\end{sphinxVerbatim}

\sphinxAtStartPar
Alternatively, if the file has only one class and one method, both can be omitted, and the runner will be selected automatically:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python\PYG{+w}{ }run\PYG{+w}{ }file\PYGZus{}name
\end{sphinxVerbatim}

\sphinxAtStartPar
Or, if there is only one file in the project, you can omit the \sphinxtitleref{file\_name} entirely:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python\PYG{+w}{ }run\PYG{+w}{ }class\PYGZus{}name\PYG{+w}{ }method\PYGZus{}name
\end{sphinxVerbatim}

\sphinxAtStartPar
If there is only one file and one class, you can also omit the \sphinxtitleref{method\_name}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python\PYG{+w}{ }run\PYG{+w}{ }class\PYGZus{}name
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally, if there is only one file, one class, and one method, you can simply use:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python\PYG{+w}{ }run\PYG{+w}{ }method\PYGZus{}name
\end{sphinxVerbatim}

\sphinxAtStartPar
Or, if everything is automatically determined (only one file, one class, and one method), you can just run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python\PYG{+w}{ }run
\end{sphinxVerbatim}

\sphinxAtStartPar
This system allows for flexible execution of your runners, making it easier to manage the different entry points in your project. You can target specific files, classes, or methods directly, depending on your needs.

\sphinxstepscope


\subsection{Presentation Layer}
\label{\detokenize{architecture/presentation/index:presentation-layer}}\label{\detokenize{architecture/presentation/index::doc}}
\sphinxAtStartPar
The \sphinxstylestrong{Presentation Layer} is responsible for handling user interactions and presenting the data. It is designed to separate the user interface (UI) concerns from the core business logic and other layers of the application.

\sphinxAtStartPar
In this layer, you’ll typically find different components responsible for displaying information to the user and capturing their inputs.

\sphinxAtStartPar
The Presentation Layer is mainly composed of the following:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{CLI Presentations}:}
\sphinxAtStartPar
Handle the command\sphinxhyphen{}line interface (CLI) interactions.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{UI Presentations}:}
\sphinxAtStartPar
Manage user interfaces (like web or graphical UIs), though this is an optional component depending on the type of application you’re building.

\end{description}

\end{enumerate}

\sphinxAtStartPar
Here’s a refined section on “What to Avoid in Presentation” for your documentation:


\subsubsection{What to Do in Presentation}
\label{\detokenize{architecture/presentation/index:what-to-do-in-presentation}}\begin{itemize}
\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Follow the Dependency Inversion Principle}:}
\sphinxAtStartPar
The Presentation Layer should depend on the \sphinxstylestrong{Application Layer}, not on \sphinxstylestrong{Infrastructure} or \sphinxstylestrong{Domain} directly. It should communicate only through services or use cases.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Use DTOs for Data Transfer}:}
\sphinxAtStartPar
Always use \sphinxstylestrong{DTOs (Data Transfer Objects)} to structure incoming and outgoing data. This ensures that the Presentation Layer does not work directly with \sphinxstylestrong{Domain Models}, reducing coupling.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Validate User Input}:}
\sphinxAtStartPar
Validate all incoming data before passing it to the \sphinxstylestrong{Application Layer}. This prevents invalid or incomplete data from reaching business logic and causing errors.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Keep Controllers Lightweight}:}
\sphinxAtStartPar
Controllers (or handlers) should only be responsible for handling requests, calling \sphinxstylestrong{Application Services}, and returning responses. Business logic should never be in controllers.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Implement Proper Error Handling}:}
\sphinxAtStartPar
Capture and format errors in the Presentation Layer before sending responses. Use proper HTTP status codes in APIs and meaningful messages in UI or CLI applications.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Ensure Idempotency in APIs}:}
\sphinxAtStartPar
If exposing an API, ensure that \sphinxstylestrong{POST, PUT, and DELETE} operations are idempotent when necessary, avoiding unintended duplicate operations.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Decouple from the Framework}:}
\sphinxAtStartPar
The Presentation Layer should not be tightly coupled to any specific framework. Keeping it loosely coupled makes it easier to change frameworks if needed.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Use a Consistent Response Format}:}
\sphinxAtStartPar
Define and follow a \sphinxstylestrong{structured response format} for all API endpoints. This makes it easier to integrate with clients.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Apply Authentication and Authorization}:}
\sphinxAtStartPar
Ensure that API endpoints and UI actions are properly secured using authentication and authorization mechanisms before calling business logic.

\end{description}

\end{itemize}


\subsubsection{What to Avoid in Presentation}
\label{\detokenize{architecture/presentation/index:what-to-avoid-in-presentation}}
\sphinxAtStartPar
In the \sphinxstylestrong{Presentation Layer}, it is crucial to maintain a clear separation of concerns. Here are some common pitfalls to avoid:
\begin{itemize}
\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Avoid Business Logic in Presentation Layer}:}
\sphinxAtStartPar
Do not include any business logic or complex decision\sphinxhyphen{}making processes in the Presentation Layer. This logic should reside in the \sphinxstylestrong{Application Layer} or the \sphinxstylestrong{Domain Layer}. The Presentation Layer should only be responsible for presenting data to the user and handling user input.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Avoid Direct Database Access}:}
\sphinxAtStartPar
Avoid direct interaction with the database in the Presentation Layer. Database access and data manipulation should be handled by the \sphinxstylestrong{Application Layer} via services or repositories.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Avoid Heavy Computation in Presentation Layer}:}
\sphinxAtStartPar
Avoid heavy computations in the \sphinxstylestrong{Presentation Layer}. The \sphinxstylestrong{Presentation Layer} should focus on displaying the data and not processing large datasets or performing calculations. These tasks should be delegated to the \sphinxstylestrong{Application} or \sphinxstylestrong{Domain} layers.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Avoid Side Effects in Presentation Layer}:}
\sphinxAtStartPar
The \sphinxstylestrong{Presentation Layer} should avoid making changes to the system state, such as saving data to the database or triggering external actions. Instead, it should communicate with the \sphinxstylestrong{Application Layer} to handle such side effects.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Avoid Logging and Debugging in Presentation Layer}:}
\sphinxAtStartPar
Avoid placing logging or debugging statements in the \sphinxstylestrong{Presentation Layer}. Logs should be handled at the \sphinxstylestrong{Service} or \sphinxstylestrong{Domain} levels, not in the UI or presentation code.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Avoid Tightly Coupled Components}:}
\sphinxAtStartPar
The \sphinxstylestrong{Presentation Layer} should not be tightly coupled to the specific implementation details of the \sphinxstylestrong{Domain} or \sphinxstylestrong{Infrastructure} layers. It should rely on abstractions such as interfaces or services to interact with the underlying layers.

\end{description}

\end{itemize}

\sphinxAtStartPar
This section ensures that the \sphinxstylestrong{Presentation Layer} stays focused on what it’s meant to do—displaying data and handling user interaction—while keeping other responsibilities in the appropriate layers.


\subsubsection{Example of a CLI Presentation}
\label{\detokenize{architecture/presentation/index:example-of-a-cli-presentation}}
\sphinxAtStartPar
Below is an example of a class that demonstrates the \sphinxstylestrong{CLI Presentation} using the \sphinxtitleref{AppCLIPresentation} class:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{application}\PYG{n+nn}{.}\PYG{n+nn}{dtos}\PYG{n+nn}{.}\PYG{n+nn}{app\PYGZus{}dto}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{AppDTO}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{application}\PYG{n+nn}{.}\PYG{n+nn}{services}\PYG{n+nn}{.}\PYG{n+nn}{app\PYGZus{}service}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{AppService}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{infrastructure}\PYG{n+nn}{.}\PYG{n+nn}{framework}\PYG{n+nn}{.}\PYG{n+nn}{appcraft}\PYG{n+nn}{.}\PYG{n+nn}{utils}\PYG{n+nn}{.}\PYG{n+nn}{component\PYGZus{}printer} \PYGZbs{}
    \PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{ComponentPrinter}


\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{AppCLIPresentation}\PYG{p}{:}

    \PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Printer}\PYG{p}{(}\PYG{n}{ComponentPrinter}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{domain} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{app}\PYG{l+s+s2}{\PYGZdq{}}

        \PYG{n+nd}{@classmethod}
        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{welcome}\PYG{p}{(}\PYG{n+nb+bp}{cls}\PYG{p}{,} \PYG{n}{app\PYGZus{}name}\PYG{p}{:} \PYG{n+nb}{str}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{message} \PYG{o}{=} \PYG{n+nb+bp}{cls}\PYG{o}{.}\PYG{n}{translate}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Welcome to }\PYG{l+s+si}{\PYGZob{}app\PYGZus{}name\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{n+nb+bp}{cls}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{n}{message}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{app\PYGZus{}name}\PYG{o}{=}\PYG{n}{app\PYGZus{}name}\PYG{p}{)}\PYG{p}{)}

        \PYG{n+nd}{@classmethod}
        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{app\PYGZus{}info}\PYG{p}{(}\PYG{n+nb+bp}{cls}\PYG{p}{,} \PYG{n}{app}\PYG{p}{:} \PYG{n}{AppDTO}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{app\PYGZus{}dict} \PYG{o}{=} \PYG{n}{app}\PYG{o}{.}\PYG{n}{to\PYGZus{}dict}\PYG{p}{(}\PYG{p}{)}
            \PYG{n+nb+bp}{cls}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{App Informations}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{k}{for} \PYG{n}{name}\PYG{p}{,} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{app\PYGZus{}dict}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                \PYG{n+nb+bp}{cls}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
                \PYG{n+nb+bp}{cls}\PYG{o}{.}\PYG{n}{print}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}

    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{app\PYGZus{}service}\PYG{p}{:} \PYG{n}{AppService}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{app\PYGZus{}service} \PYG{o}{=} \PYG{n}{app\PYGZus{}service}

    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{show\PYGZus{}informations}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{n}{app} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{app\PYGZus{}service}\PYG{o}{.}\PYG{n}{get\PYGZus{}app}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{Printer}\PYG{o}{.}\PYG{n}{app\PYGZus{}info}\PYG{p}{(}\PYG{n}{app}\PYG{p}{)}

    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{start}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{n}{app} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{app\PYGZus{}service}\PYG{o}{.}\PYG{n}{get\PYGZus{}app}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{Printer}\PYG{o}{.}\PYG{n}{welcome}\PYG{p}{(}\PYG{n}{app}\PYG{o}{.}\PYG{n}{name}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this example:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{AppCLIPresentation} is a class responsible for presenting the application information in a command\sphinxhyphen{}line interface.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{Printer} is a nested class that extends \sphinxtitleref{ComponentPrinter} and contains methods to display different pieces of information (like \sphinxtitleref{welcome()} and \sphinxtitleref{app\_info()}).

\item {} 
\sphinxAtStartPar
\sphinxtitleref{show\_informations()} calls the \sphinxtitleref{app\_info()} method to display detailed information about the app, such as name, version, environment, etc.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{start()} displays a welcome message with the app’s name.

\end{itemize}

\sphinxAtStartPar
This is just one of the ways to implement the Presentation Layer, and you can expand it based on your project’s needs. The Presentation Layer can be used for both presenting data and handling interactions, with flexibility for your particular application.

\sphinxstepscope


\subsection{Application Layer}
\label{\detokenize{architecture/application/index:application-layer}}\label{\detokenize{architecture/application/index::doc}}
\sphinxAtStartPar
The \sphinxstylestrong{Application Layer} is responsible for orchestrating business logic within the application. It sits between the \sphinxstylestrong{Presentation Layer} and the \sphinxstylestrong{Domain Layer}, handling the flow of data and ensuring that all interactions between the different layers are seamless. This layer often contains \sphinxstylestrong{Services}, \sphinxstylestrong{DTOs} (Data Transfer Objects), \sphinxstylestrong{Mappers}, and sometimes \sphinxstylestrong{Use Cases}.

\sphinxAtStartPar
The \sphinxstylestrong{Application Layer} coordinates the actions of the \sphinxstylestrong{Domain Layer} by interacting with models, repositories, and services, and it prepares the data to be sent to the \sphinxstylestrong{Presentation Layer}.

\sphinxAtStartPar
Aqui está a seção \sphinxstylestrong{“What to Do in Application”}, seguindo o mesmo formato da \sphinxstylestrong{“What to Avoid in Application”}:


\subsubsection{What to Do in Application}
\label{\detokenize{architecture/application/index:what-to-do-in-application}}
\sphinxAtStartPar
In the \sphinxstylestrong{Application Layer}, it is essential to follow best practices to ensure the proper orchestration of business logic and system interactions. Here are some key principles to follow:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Orchestrate Business Logic, Do Not Implement It}:
The \sphinxstylestrong{Application Layer} should coordinate interactions between the \sphinxstylestrong{Domain Layer} and external layers. Avoid implementing business rules here; instead, delegate them to the \sphinxstylestrong{Domain Layer}.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Use DTOs for Data Transfer}:
Introduce \sphinxstylestrong{Data Transfer Objects (DTOs)} to shape the data exchanged between the \sphinxstylestrong{Application Layer} and \sphinxstylestrong{Presentation Layer}, ensuring separation of concerns and avoiding unnecessary dependencies on domain models.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Implement Application Services}:
Keep application logic within well\sphinxhyphen{}defined \sphinxstylestrong{Application Services}, ensuring that use cases are clearly implemented and reusable. These services should act as intermediaries between the \sphinxstylestrong{Presentation Layer} and the \sphinxstylestrong{Domain Layer}.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Leverage Mappers for Data Transformation}:
Use \sphinxstylestrong{Mappers} to convert data between \sphinxstylestrong{DTOs} and \sphinxstylestrong{Domain Models}. This ensures each layer remains independent and prevents unnecessary coupling.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Enforce Transaction Boundaries}:
If an application service involves multiple repository calls, ensure that transactions are properly managed to maintain data consistency.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Keep Dependencies on External Layers Minimal}:
The \sphinxstylestrong{Application Layer} should depend on the \sphinxstylestrong{Domain Layer} but should not have direct dependencies on external frameworks or infrastructure. Use dependency injection to manage dependencies effectively.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Ensure Idempotency for Application Services}:
Application services should be designed to handle duplicate requests safely and prevent unintended side effects.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Write Unit and Integration Tests}:
The \sphinxstylestrong{Application Layer} should be well\sphinxhyphen{}tested, covering different scenarios for service orchestration, data transformation, and interactions with the \sphinxstylestrong{Domain Layer}.

\end{itemize}


\subsubsection{What to Avoid in Application}
\label{\detokenize{architecture/application/index:what-to-avoid-in-application}}
\sphinxAtStartPar
While working within the \sphinxstylestrong{Application Layer}, it’s important to adhere to the following guidelines to ensure a clean and maintainable architecture. Here are some common practices to avoid:
\begin{itemize}
\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Avoid Business Logic in Application Layer}:}
\sphinxAtStartPar
The \sphinxstylestrong{Application Layer} should not contain complex business logic. Business rules, validations, and domain\sphinxhyphen{}specific logic should reside in the \sphinxstylestrong{Domain Layer}. The Application Layer is responsible for orchestrating the flow of data and calls to other layers, not for implementing business rules.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Avoid Direct Interaction with Presentation Layer}:}
\sphinxAtStartPar
The \sphinxstylestrong{Application Layer} should never interact directly with the \sphinxstylestrong{Presentation Layer}. Its responsibility is to handle the orchestration of processes and provide data to be presented by the Presentation Layer. The Application Layer should not be concerned with rendering data or user\sphinxhyphen{}facing interactions.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Avoid Data Formatting or Rendering}:}
\sphinxAtStartPar
The \sphinxstylestrong{Application Layer} should not be responsible for formatting data, rendering views, or handling any user\sphinxhyphen{}facing interactions. This is the responsibility of the \sphinxstylestrong{Presentation Layer}. The Application Layer should focus on managing application flow and communicating with the \sphinxstylestrong{Domain Layer} and other necessary components.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Avoid Persistence Operations in Application Layer}:}
\sphinxAtStartPar
The \sphinxstylestrong{Application Layer} should not directly handle data persistence or database interactions. These tasks should be delegated to the \sphinxstylestrong{Domain Layer} or \sphinxstylestrong{Infrastructure Layer}, ensuring that the Application Layer remains focused on its orchestration role.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Avoid Tightly Coupled Components}:}
\sphinxAtStartPar
Avoid tightly coupling the \sphinxstylestrong{Application Layer} to the \sphinxstylestrong{Presentation Layer} or the \sphinxstylestrong{Infrastructure Layer}. The Application Layer should rely on abstractions and interfaces to communicate with other layers. This promotes flexibility, testability, and separation of concerns.

\end{description}

\end{itemize}

\sphinxAtStartPar
By adhering to these practices, the \sphinxstylestrong{Application Layer} remains focused on its core responsibility—managing application flow—while ensuring that other concerns, like business logic and presentation, are handled in the appropriate layers.


\subsubsection{Example of a DTO}
\label{\detokenize{architecture/application/index:example-of-a-dto}}
\sphinxAtStartPar
A \sphinxstylestrong{DTO} (Data Transfer Object) is a simple object used to transfer data between the \sphinxstylestrong{Application} and \sphinxstylestrong{Presentation Layers}. It is often used to simplify complex domain models and provide data in a form that is easy to transfer over a network or display in a user interface.

\sphinxAtStartPar
Here’s an example of a DTO:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{AppDTO}\PYG{p}{:}
    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}
        \PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name}\PYG{p}{:} \PYG{n+nb}{str}\PYG{p}{,} \PYG{n}{version}\PYG{p}{:} \PYG{n+nb}{str}\PYG{p}{,}
        \PYG{n}{environment}\PYG{p}{:} \PYG{n+nb}{str}\PYG{p}{,} \PYG{n}{debug\PYGZus{}mode}\PYG{p}{:} \PYG{n+nb}{bool}
    \PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{name} \PYG{o}{=} \PYG{n}{name}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{version} \PYG{o}{=} \PYG{n}{version}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{environment} \PYG{o}{=} \PYG{n}{environment}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{debug\PYGZus{}mode} \PYG{o}{=} \PYG{n}{debug\PYGZus{}mode}

    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{to\PYGZus{}dict}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{\PYGZob{}}
            \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{name}\PYG{p}{,}
            \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{version}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{version}\PYG{p}{,}
            \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{environment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{environment}\PYG{p}{,}
            \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{debug\PYGZus{}mode}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{debug\PYGZus{}mode}
        \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this example, the \sphinxtitleref{AppDTO} class is used to structure the application data in a way that can be easily transferred to the \sphinxstylestrong{Presentation Layer}.


\subsubsection{Example of a Mapper}
\label{\detokenize{architecture/application/index:example-of-a-mapper}}
\sphinxAtStartPar
A \sphinxstylestrong{Mapper} is responsible for converting between different types of objects or data structures. In the context of the \sphinxstylestrong{Application Layer}, a mapper is used to convert \sphinxstylestrong{Domain} models to \sphinxstylestrong{DTOs} and vice versa.

\sphinxAtStartPar
Here is an example of a Mapper that converts a \sphinxtitleref{Domain} model to a \sphinxtitleref{DTO}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{application}\PYG{n+nn}{.}\PYG{n+nn}{dtos}\PYG{n+nn}{.}\PYG{n+nn}{app\PYGZus{}dto}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{AppDTO}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{domain}\PYG{n+nn}{.}\PYG{n+nn}{models}\PYG{n+nn}{.}\PYG{n+nn}{app}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{App}


\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{AppMapper}\PYG{p}{:}
    \PYG{n+nd}{@staticmethod}
    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{to\PYGZus{}dto}\PYG{p}{(}\PYG{n}{app}\PYG{p}{:} \PYG{n}{App}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{AppDTO}\PYG{p}{(}
            \PYG{n}{name}\PYG{o}{=}\PYG{n}{app}\PYG{o}{.}\PYG{n}{name}\PYG{p}{,}
            \PYG{n}{version}\PYG{o}{=}\PYG{n}{app}\PYG{o}{.}\PYG{n}{version}\PYG{p}{,}
            \PYG{n}{environment}\PYG{o}{=}\PYG{n}{app}\PYG{o}{.}\PYG{n}{environment}\PYG{p}{,}
            \PYG{n}{debug\PYGZus{}mode}\PYG{o}{=}\PYG{n}{app}\PYG{o}{.}\PYG{n}{debug\PYGZus{}mode}\PYG{p}{,}
        \PYG{p}{)}

    \PYG{n+nd}{@staticmethod}
    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{to\PYGZus{}domain}\PYG{p}{(}\PYG{n}{app\PYGZus{}dto}\PYG{p}{:} \PYG{n}{AppDTO}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{App}\PYG{p}{(}
            \PYG{n}{name}\PYG{o}{=}\PYG{n}{app\PYGZus{}dto}\PYG{o}{.}\PYG{n}{name}\PYG{p}{,}
            \PYG{n}{version}\PYG{o}{=}\PYG{n}{app\PYGZus{}dto}\PYG{o}{.}\PYG{n}{version}\PYG{p}{,}
            \PYG{n}{environment}\PYG{o}{=}\PYG{n}{app\PYGZus{}dto}\PYG{o}{.}\PYG{n}{environment}\PYG{p}{,}
            \PYG{n}{debug\PYGZus{}mode}\PYG{o}{=}\PYG{n}{app\PYGZus{}dto}\PYG{o}{.}\PYG{n}{debug\PYGZus{}mode}
        \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this example, the \sphinxtitleref{AppMapper} class defines methods for converting between the \sphinxstylestrong{Domain} model \sphinxtitleref{App} and the \sphinxstylestrong{DTO} \sphinxtitleref{AppDTO}. This separation allows for cleaner code and better maintainability.


\subsubsection{Example of a Service}
\label{\detokenize{architecture/application/index:example-of-a-service}}
\sphinxAtStartPar
A \sphinxstylestrong{Service} in the \sphinxstylestrong{Application Layer} is responsible for executing business logic and coordinating operations between the \sphinxstylestrong{Domain} and \sphinxstylestrong{Presentation} layers. A \sphinxstylestrong{Service} typically calls the \sphinxstylestrong{Domain Layer} to retrieve or manipulate data and then formats the data for the \sphinxstylestrong{Presentation Layer}.

\sphinxAtStartPar
Here’s an example of an \sphinxstylestrong{Application Service}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{application}\PYG{n+nn}{.}\PYG{n+nn}{dtos}\PYG{n+nn}{.}\PYG{n+nn}{app\PYGZus{}dto}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{AppDTO}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{application}\PYG{n+nn}{.}\PYG{n+nn}{mappers}\PYG{n+nn}{.}\PYG{n+nn}{app\PYGZus{}mapper}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{AppMapper}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{domain}\PYG{n+nn}{.}\PYG{n+nn}{interfaces}\PYG{n+nn}{.}\PYG{n+nn}{adapters}\PYG{n+nn}{.}\PYG{n+nn}{app\PYGZus{}adapter\PYGZus{}interface}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{p}{(}
    \PYG{n}{AppAdapterInterface}\PYG{p}{,}
\PYG{p}{)}


\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{AppService}\PYG{p}{:}
    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{app\PYGZus{}adapter}\PYG{p}{:} \PYG{n}{AppAdapterInterface}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{adapter} \PYG{o}{=} \PYG{n}{app\PYGZus{}adapter}

    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{get\PYGZus{}app}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{AppDTO}\PYG{p}{:}
        \PYG{n}{app} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{adapter}\PYG{o}{.}\PYG{n}{get\PYGZus{}app}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{app\PYGZus{}dto} \PYG{o}{=} \PYG{n}{AppMapper}\PYG{o}{.}\PYG{n}{to\PYGZus{}dto}\PYG{p}{(}\PYG{n}{app}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{app\PYGZus{}dto}
\end{sphinxVerbatim}

\sphinxAtStartPar
Aqui está a explicação ajustada para refletir corretamente o fluxo de dados no exemplo:

\sphinxAtStartPar
—

\sphinxAtStartPar
In this example, the \sphinxtitleref{AppService} is responsible for retrieving application information through the \sphinxtitleref{AppAdapterInterface}, which abstracts the infrastructure details.
The retrieved \sphinxtitleref{App} object belongs to the \sphinxstylestrong{Domain Layer}.
To ensure a proper separation of concerns, the service uses the \sphinxtitleref{AppMapper} to convert the domain model into an \sphinxtitleref{AppDTO}, which is specifically designed for communication with the \sphinxstylestrong{Presentation Layer}.
By doing so, \sphinxtitleref{AppService} acts as an intermediary, orchestrating data transformation and enforcing business rules \sphinxstylestrong{between the Domain and Presentation layers}, while keeping the infrastructure details decoupled.

\sphinxstepscope


\subsection{Domain Layer}
\label{\detokenize{architecture/domain/index:domain-layer}}\label{\detokenize{architecture/domain/index::doc}}
\sphinxAtStartPar
The \sphinxstylestrong{Domain Layer} is the heart of your application, where the business logic and rules are defined. It contains the \sphinxstylestrong{models} that represent your business entities, and the \sphinxstylestrong{infrastructure interfaces} that define the contract for persisting and retrieving these entities. This layer is independent of any external concerns, such as databases or frameworks, and focuses solely on the core logic of the application.

\sphinxAtStartPar
The Domain Layer serves to encapsulate the business rules and logic, ensuring that the rest of the system can interact with it without knowing the underlying implementation details.


\subsubsection{What to Do in Domain}
\label{\detokenize{architecture/domain/index:what-to-do-in-domain}}
\sphinxAtStartPar
In the \sphinxstylestrong{Domain Layer}, it is essential to follow best practices to ensure a clean, maintainable, and scalable architecture. Here are some key principles to follow:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Encapsulate Business Logic}:
The Domain Layer should be the central place for business rules and domain logic. Keep this layer independent of external frameworks or infrastructure to ensure testability and reusability.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Use Rich Domain Models}:
Prefer using rich domain models that encapsulate both data and behavior instead of relying only on anemic data structures. This helps enforce domain rules and improves maintainability.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Keep Domain Models Independent}:
Avoid dependencies on infrastructure, frameworks, or database models. The domain models should represent the business concepts without being affected by external concerns.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Define Clear Boundaries}:
Clearly define the boundaries of your domain entities and value objects. Ensure that changes to one entity do not inadvertently impact unrelated parts of the system.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Follow Interface\sphinxhyphen{}Based Design for Repositories}:
Define repository interfaces in the Domain Layer, keeping the implementation details in the Infrastructure Layer. This abstraction allows easy substitution and testing.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Use Value Objects When Applicable}:
Instead of using primitive types everywhere, consider using \sphinxstylestrong{Value Objects} for attributes that have specific business meaning, ensuring data consistency and enforcing constraints.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Ensure Immutability When Possible}:
Make domain models immutable whenever possible to prevent unintended side effects and maintain a predictable state throughout the application.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Write Unit Tests for Domain Logic}:
The Domain Layer should be highly testable. Write unit tests to verify business rules and domain logic independently from external dependencies.

\end{itemize}


\subsubsection{What to Avoid in Domain}
\label{\detokenize{architecture/domain/index:what-to-avoid-in-domain}}
\sphinxAtStartPar
In the \sphinxstylestrong{Domain Layer}, it is crucial to maintain a clear separation of concerns. Here are some common pitfalls to avoid:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Business Logic in Other Layers}: Avoid placing business logic in the \sphinxstylestrong{Application Layer}, \sphinxstylestrong{Presentation Layer}, or \sphinxstylestrong{Infrastructure Layer}. The \sphinxstylestrong{Domain Layer} should be the place for business rules and models.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Direct Database Access}: Avoid having database\sphinxhyphen{}specific code or direct access to databases in the \sphinxstylestrong{Domain Layer}. Use repository interfaces to abstract away the database interaction.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{External Dependencies}: The \sphinxstylestrong{Domain Layer} should not have dependencies on external frameworks, libraries, or infrastructure concerns. Keep it focused on the core business logic and rules.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{UI Logic}: Avoid placing UI\sphinxhyphen{}related logic in the \sphinxstylestrong{Domain Layer}. The \sphinxstylestrong{Domain} should be agnostic to the user interface and should not know how data is presented to the user.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Global State}: The \sphinxstylestrong{Domain Layer} should not depend on or modify global state. The state should be encapsulated in objects and managed through domain logic.

\end{itemize}


\subsubsection{Example of a Model}
\label{\detokenize{architecture/domain/index:example-of-a-model}}
\sphinxAtStartPar
Here’s an example of a \sphinxstylestrong{Model} in the \sphinxstylestrong{Domain Layer}, representing a \sphinxstylestrong{User}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} domain/models/user.py}
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{User}\PYG{p}{:}
    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{user\PYGZus{}id}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{,} \PYG{n}{name}\PYG{p}{:} \PYG{n+nb}{str}\PYG{p}{,} \PYG{n}{email}\PYG{p}{:} \PYG{n+nb}{str}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{user\PYGZus{}id} \PYG{o}{=} \PYG{n}{user\PYGZus{}id}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{name} \PYG{o}{=} \PYG{n}{name}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{email} \PYG{o}{=} \PYG{n}{email}

    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{change\PYGZus{}name}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{new\PYGZus{}name}\PYG{p}{:} \PYG{n+nb}{str}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{name} \PYG{o}{=} \PYG{n}{new\PYGZus{}name}

    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{change\PYGZus{}email}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{new\PYGZus{}email}\PYG{p}{:} \PYG{n+nb}{str}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{email} \PYG{o}{=} \PYG{n}{new\PYGZus{}email}

    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}repr\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{User(id=}\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{user\PYGZus{}id}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, name=}\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{name}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, email=}\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{email}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{)}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this example, the \sphinxtitleref{User} class is a core business model that represents a user entity. It encapsulates the data and behaviors related to a user in the system.


\subsubsection{Example of Repository Interface}
\label{\detokenize{architecture/domain/index:example-of-repository-interface}}
\sphinxAtStartPar
Here’s an example of a \sphinxstylestrong{Repository Interface} in the \sphinxstylestrong{Domain Layer}, defining methods for interacting with \sphinxstylestrong{User} data:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} domain/repositories/user\PYGZus{}repository\PYGZus{}interface.py}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{abc}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{ABC}\PYG{p}{,} \PYG{n}{abstractmethod}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{domain}\PYG{n+nn}{.}\PYG{n+nn}{models}\PYG{n+nn}{.}\PYG{n+nn}{user}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{User}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{UserRepositoryInterface}\PYG{p}{(}\PYG{n}{ABC}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nd}{@abstractmethod}
    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{get\PYGZus{}by\PYGZus{}id}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{user\PYGZus{}id}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{User}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Retrieve a user by ID\PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{pass}

    \PYG{n+nd}{@abstractmethod}
    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{create}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{user}\PYG{p}{:} \PYG{n}{User}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Create a new user\PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{pass}

    \PYG{n+nd}{@abstractmethod}
    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{update}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{user}\PYG{p}{:} \PYG{n}{User}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Update an existing user\PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{pass}

    \PYG{n+nd}{@abstractmethod}
    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{delete}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{user}\PYG{p}{:} \PYG{n}{User}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Delete a user\PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{pass}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this example, the \sphinxtitleref{UserRepositoryInterface} defines the contract for repository operations such as creating, updating, and deleting users. This repository is abstract and doesn’t deal with database specifics—it only specifies what actions can be performed on the \sphinxstylestrong{User} entity.


\subsubsection{Example of Adapter Interface}
\label{\detokenize{architecture/domain/index:example-of-adapter-interface}}
\sphinxAtStartPar
This is an example of an \sphinxstylestrong{Adapter Interface} in the \sphinxstylestrong{Domain Layer}, defining a contract for retrieving \sphinxstylestrong{App} data:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} domain/adapters/app\PYGZus{}adapter\PYGZus{}interface.py}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{abc}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{ABC}\PYG{p}{,} \PYG{n}{abstractmethod}

\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{domain}\PYG{n+nn}{.}\PYG{n+nn}{models}\PYG{n+nn}{.}\PYG{n+nn}{app}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{App}


\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{AppAdapterInterface}\PYG{p}{(}\PYG{n}{ABC}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nd}{@abstractmethod}
    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{get\PYGZus{}app}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{App}\PYG{p}{:}
        \PYG{k}{pass}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this example, the \sphinxtitleref{AppAdapterInterface} establishes a clear contract for accessing application\sphinxhyphen{}related data.
This interface does not deal with infrastructure\sphinxhyphen{}specific details (such as databases, filesystem or external APIs); instead, it defines the expected behavior that any concrete adapter must implement.
By using this abstraction, the \sphinxstylestrong{Application Layer} can interact with the infrastructure in a decoupled manner, ensuring better maintainability and testability.

\sphinxstepscope


\subsection{Infrastructure Layer}
\label{\detokenize{architecture/infrastructure/index:infrastructure-layer}}\label{\detokenize{architecture/infrastructure/index::doc}}

\subsubsection{Under construction}
\label{\detokenize{architecture/infrastructure/index:under-construction}}
\sphinxstepscope


\subsection{Application Flow}
\label{\detokenize{architecture/flow/index:application-flow}}\label{\detokenize{architecture/flow/index:id1}}\label{\detokenize{architecture/flow/index::doc}}
\sphinxAtStartPar
This document describes the request and response flow in the application, ensuring a clear separation of concerns and proper layer responsibilities.


\subsubsection{Request Flow}
\label{\detokenize{architecture/flow/index:request-flow}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Runner (entrypoint)} → Instantiates the application layers.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Presentation} → Receives user input, converts it into DTO + Filters.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Mapper (Application)} → Converts DTO to Domain Model.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Service (Application)} → Applies business rules, working with Domain Model.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Repository (Application)} → Sends Domain Model or Filters to a Adapter.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Adapter (Infrastructure)} → Interacts with the database and returns the Infrastructure Model.

\end{enumerate}


\subsubsection{Response Flow}
\label{\detokenize{architecture/flow/index:response-flow}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Adapter (Infrastructure)} → Returns the Infrastructure Model.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Mapper (Infrastructure)} → Converts Infrastructure Model to Domain Model.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Repository (Application)} → Returns the Domain Model.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Service (Application)} → Applies business rules, returning the Domain Model.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Mapper (Application)} → Converts Domain Model to DTO.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Presentation} → Prepares the API response.

\end{enumerate}

\sphinxAtStartPar
This architecture ensures full decoupling between layers, making the system more maintainable and testable.

\sphinxstepscope


\section{Contributing}
\label{\detokenize{contributing/index:contributing}}\label{\detokenize{contributing/index:id1}}\label{\detokenize{contributing/index::doc}}
\sphinxAtStartPar
We appreciate your interest in contributing! You can contribute in three ways:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{contributing/index:id2}]{\sphinxsamedocref{Creating New Templates}}}.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{contributing/index:id3}]{\sphinxsamedocref{Updating Existing Templates}}}.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{contributing/index:id5}]{\sphinxsamedocref{Translating Templates}}}.

\end{enumerate}


\subsection{Creating New Templates}
\label{\detokenize{contributing/index:id2}}
\sphinxAtStartPar
To create a new template, follow these steps:
\begin{description}
\sphinxlineitem{1️⃣ \sphinxstylestrong{Clone the repository}:}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
git\PYG{+w}{ }clone\PYG{+w}{ }https://github.com/duxtec/appcraft.git
\end{sphinxVerbatim}

\sphinxlineitem{2️⃣ \sphinxstylestrong{Navigate to the repository folder}:}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd}\PYG{+w}{ }appcraft
\end{sphinxVerbatim}

\sphinxlineitem{3️⃣ \sphinxstylestrong{Run the command to create a new template}:}\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python\PYG{+w}{ }appcraft/utils/template\PYGZus{}creator.py\PYG{+w}{ }\PYGZlt{}template\PYGZus{}name\PYGZgt{}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
This command will generate a new folder:
\sphinxcode{\sphinxupquote{`
appcraft/templates/<template\_name>/
`}}

\sphinxlineitem{4️⃣ \sphinxstylestrong{Inside this folder, update the `\_\_init\_\_.py` file}:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Add a \sphinxtitleref{description} to describe the template.

\item {} \begin{description}
\sphinxlineitem{Activate the template by setting the class constant:}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{active}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }True
\end{sphinxVerbatim}

\end{description}

\item {} 
\sphinxAtStartPar
The \sphinxtitleref{files/} folder inside contains the template’s core files.

\end{itemize}

\sphinxlineitem{5️⃣ \sphinxstylestrong{Develop or Edit the Template Using a Temporary Project}}
\sphinxAtStartPar
It is \sphinxstylestrong{not recommended} to edit templates directly inside the \sphinxtitleref{appcraft/templates/<template\_name>} folder. This approach has several limitations:
\begin{description}
\sphinxlineitem{\sphinxstylestrong{Why?}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Dependency Issues}: Templates often depend on a base template or other templates, which are not recognized properly when editing them in isolation.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Linting Problems}: Linters and IDEs may fail to detect dependencies, leading to false errors and a poor development experience.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Risk of Breaking the Template Structure}: Direct modifications may lead to inconsistencies or missing files.

\end{itemize}

\end{description}

\sphinxAtStartPar
\sphinxstylestrong{Solution: Use a Temporary Project}
To safely develop or edit a template, it is best to use a \sphinxstylestrong{Temporary Project}. This allows you to work inside a fully functional AppCraft\sphinxhyphen{}generated project, where all dependencies, configurations, and integrations work correctly.

\sphinxAtStartPar
Instructions for creating a temporary project can be found here: {\hyperref[\detokenize{contributing/index:id5}]{\sphinxsamedocref{Working in a temporary project}}}.

\end{description}

\sphinxAtStartPar
6️⃣ \sphinxstylestrong{Submit a pull request with the new template}!


\subsection{Updating Existing Templates}
\label{\detokenize{contributing/index:id3}}
\sphinxAtStartPar
Updating an existing template follows the same process as creating a new one.
Simply \sphinxstylestrong{skip steps 3 and 4} and proceed with the rest of the instructions.

\sphinxAtStartPar
For detailed steps, refer to {\hyperref[\detokenize{contributing/index:id2}]{\sphinxsamedocref{Creating New Templates}}}.


\subsection{Translating Templates}
\label{\detokenize{contributing/index:id5}}
\sphinxAtStartPar
To translate templates into another language:

\sphinxAtStartPar
1️⃣ \sphinxstylestrong{Identify the template to translate}.

\sphinxAtStartPar
2️⃣ \sphinxstylestrong{Create a new language folder inside the template}:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
appcraft/templates/\PYGZlt{}template\PYGZus{}name\PYGZgt{}/other\PYGZus{}files/locale/
├──\PYG{+w}{ }en/\PYG{+w}{  }\PYG{c+c1}{\PYGZsh{} English}
├──\PYG{+w}{ }pt/\PYG{+w}{  }\PYG{c+c1}{\PYGZsh{} Portuguese}
├──\PYG{+w}{ }es/\PYG{+w}{  }\PYG{c+c1}{\PYGZsh{} Spanish}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
3️⃣ \sphinxstylestrong{Translate relevant files} while maintaining consistency.

\sphinxAtStartPar
4️⃣ \sphinxstylestrong{Create a new demo project and test the translation}.

\sphinxAtStartPar
5️⃣ \sphinxstylestrong{Submit a pull request with the translated version}.


\subsection{Why Use a Temporary Project?}
\label{\detokenize{contributing/index:why-use-a-temporary-project}}
\sphinxAtStartPar
When working with templates, you might be tempted to edit them directly inside the \sphinxtitleref{appcraft/templates/} folder. However, this approach has several drawbacks:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Dependency Issues:} Templates often depend on a base template or other templates, which are not recognized properly when editing them in isolation.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Linting Problems:} Linters and IDEs may fail to recognize dependencies, leading to false errors and a poor development experience.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Risk of Breaking the Template Structure:} Direct modifications inside \sphinxtitleref{appcraft/templates/} may lead to inconsistencies or missing files in the final template.

\end{itemize}

\sphinxAtStartPar
To avoid these issues, \sphinxstylestrong{the recommended approach is to use a Temporary Project}, which allows you to develop templates inside a fully functional AppCraft\sphinxhyphen{}generated project. This ensures that all dependencies, configurations, and integrations work correctly before saving the template.


\subsection{Working in a temporary project}
\label{\detokenize{contributing/index:id6}}
\sphinxAtStartPar
\sphinxstylestrong{To work in a temporary project:}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Uninstall AppCraft (if installed)}:}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip\PYG{+w}{ }uninstall\PYG{+w}{ }appcraft
\end{sphinxVerbatim}

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Navigate to the cloned AppCraft repository}:}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd}\PYG{+w}{ }appcraft
\end{sphinxVerbatim}

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Install the local version}:}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}e\PYG{+w}{ }.
\end{sphinxVerbatim}

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{Create a new project}:}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
appcraft\PYG{+w}{ }init\PYG{+w}{ }\PYGZlt{}template\PYGZus{}name\PYGZgt{}\PYG{+w}{ }\PYG{o}{[}dependencies\PYG{o}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Replace \sphinxtitleref{<template\_name>} with the template you’re working on and specify any additional dependencies.

\sphinxAtStartPar
\sphinxstylestrong{The temporary project will be created in}:
\sphinxcode{\sphinxupquote{`
appcraft/templates/temp/
`}}

\sphinxAtStartPar
This project mirrors an AppCraft\sphinxhyphen{}initialized project, allowing safe editing.

\end{description}

\item {} \begin{description}
\sphinxlineitem{\sphinxstylestrong{After modifying or creating files in the temporary project, save the template}:}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
python\PYG{+w}{ }appcraft/utils/template\PYGZus{}saver.py\PYG{+w}{ }\PYGZlt{}template\PYGZus{}name\PYGZgt{}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Modify only one template at a time}.

\sphinxAtStartPar
If you need to modify another template, \sphinxstylestrong{save the current template first}, then repeat the process starting from \sphinxtitleref{appcraft init}.

\end{description}

\end{enumerate}


\subsection{Ready to Contribute?}
\label{\detokenize{contributing/index:ready-to-contribute}}
\sphinxAtStartPar
If you have any questions, feel free to open an issue or reach out to the maintainers.

\sphinxAtStartPar
🚀 Happy Coding!

\sphinxstepscope


\section{Contact}
\label{\detokenize{contact:contact}}\label{\detokenize{contact::doc}}

\subsection{Under construction}
\label{\detokenize{contact:under-construction}}
\sphinxstepscope


\section{Versions}
\label{\detokenize{versions/index:versions}}\label{\detokenize{versions/index::doc}}
\sphinxAtStartPar
This documentation contains multiple versions. Select the version you want to view:

\sphinxAtStartPar
\sphinxstylestrong{Available Versions:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{../../latest/index.html}{Latest Version (0.5.4).}

\end{itemize}


\section{Version Information}
\label{\detokenize{index:version-information}}
\sphinxAtStartPar
This documentation corresponds to AppCraft version 0.5.4. For other versions, refer to the \sphinxhref{../latest/versions/index.html}{version selection page}.


\section{Features in Version 0.5.4}
\label{\detokenize{index:features-in-version-release}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Easy project creation and setup.

\item {} 
\sphinxAtStartPar
Initial architecture and structure for new projects.

\item {} 
\sphinxAtStartPar
Introduction of templates:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Base

\item {} 
\sphinxAtStartPar
Logs

\item {} 
\sphinxAtStartPar
Locales

\item {} 
\sphinxAtStartPar
Flask UI

\item {} 
\sphinxAtStartPar
Flask API

\item {} 
\sphinxAtStartPar
Web Scrapping

\end{itemize}

\end{itemize}

\sphinxAtStartPar
For detailed information, explore the sections listed in the {\hyperref[\detokenize{index:overview}]{\sphinxsamedocref{Overview}}}.



\renewcommand{\indexname}{Index}
\printindex
\end{document}